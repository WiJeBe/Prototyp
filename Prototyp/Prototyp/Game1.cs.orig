using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;

namespace Prototyp
{

    /*
     Att läsa!
     Hej!
     När du, blir mer välkomnande och personligt när jag säger "du", kollar runt i klasserna kommer du se att det mest bara är oläsligt kladd som står där. 
     Jag ber om ursäkt för det faktumet och lovar att se över formuleringar och tankegångar under dagen imorgon. Har du ändå frågor kan jag nås via min 
     mail (JvAulin@gmail.com), skype (joakim.aulin) eller telefon (0704946874). Telefonen är knasig så om du inte kommer fram på den, skicka ett mess så 
     ringer jag upp. 
 
     Om du promt vill börja på en del imorgon eller inatt så rekomenderar jag platformarna, normal-varianten. När du fått dom att fungera korrekt kan du
     bygga en antingen en manager klass eller metod (metoden i Game1 förslagsvis) som styr intervallet för släpp av nya Pads.
  
     // JvA
 
     */

    public class Game1 : Microsoft.Xna.Framework.Game
    {
        GraphicsDeviceManager graphics;
        SpriteBatch sB;


        public static int screenWidth, screenHeight; // Storleken på fönstret

        Unit_Char p1;

        PadManager padManager;
        
        public Game1()
        {
            graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";
        }


        protected override void Initialize()
        {
            // TODO: Add your initialization logic here

            base.Initialize();
        }


        protected override void LoadContent()
        {
            sB = new SpriteBatch(GraphicsDevice);


            IsMouseVisible = true;

            // Storleken på fönstret sätts
            screenHeight = graphics.PreferredBackBufferHeight = 600;
            screenWidth = graphics.PreferredBackBufferWidth = 800;
            graphics.ApplyChanges();

            

            // skapar en padManager variabel
            padManager = new PadManager();

            Textures.LoadTextures(Content);

            p1 = new Unit_Char(new Vector2(100, 100), new Vector2(1, 1), new Vector2(40, 9.81f), PlayerID.P1);

        }


        protected override void UnloadContent()
        { }


        protected override void Update(GameTime gT)
        {
            // Esc avslutar spelet...
            if (Keyboard.GetState().IsKeyDown(Keys.Escape))
                this.Exit();


            //Uppdatera padmanager
            padManager.Update(gT);


            KeyMouse.Update();

            p1.Update(gT);



            base.Update(gT);
        }


        protected override void Draw(GameTime gT)
        {

            GraphicsDevice.Clear(Color.CornflowerBlue);
            sB.Begin();

            // Ritar ut padManager
            padManager.Draw(sB);

            sB.End();
            base.Draw(gT);

            GraphicsDevice.Clear(Color.CornflowerBlue);

            sB.Begin();

            p1.Draw(sB);

            sB.End();

            base.Draw(gT);

        }
    }
}
/*
 ATT-GÖRA LISTA!
 - = Ej påbörjad
 * = Påbörjad
 V = Klar
Namn	:	Status	:		Uppgift 
		:		-		:	Anpassa acc-variabeln så att karaktären "bromsar in" vid riktningsbyte
		:		-		:	Gör så att acc minskar om spelaren inte håller inne en "sido-styrnings knapp" 
JvA	:		V		:	Implementera metoder för styrningskontroll.
JvA	:		V		:	Koppla ihop styrningskontrollerna med metoderna i Unit så att enheten kan utföra något när kontrollen används.
JvA	:		*		:	Matematiken i "Gravity" metoden behöver ses över av någon som känner sig mer säker på ämnet än jag. //JvA
 
 
 
 */
